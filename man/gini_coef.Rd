% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/num-gini_coef.R
\name{gini_coef}
\alias{gini_coef}
\alias{gini_coef.data.frame}
\alias{gini_coef_vec}
\title{Normalized Gini coefficient}
\usage{
gini_coef(data, ...)

\method{gini_coef}{data.frame}(data, truth, estimate, na_rm = TRUE, case_weights = NULL, ...)

gini_coef_vec(truth, estimate, na_rm = TRUE, case_weights = NULL, ...)
}
\arguments{
\item{data}{A \code{data.frame} containing the columns specified by the \code{truth}
and \code{estimate} arguments.}

\item{...}{Not currently used.}

\item{truth}{The column identifier for the true results
(that is \code{numeric}). This should be an unquoted column name although
this argument is passed by expression and supports
\link[rlang:topic-inject]{quasiquotation} (you can unquote column
names). For \verb{_vec()} functions, a \code{numeric} vector.}

\item{estimate}{The column identifier for the predicted
results (that is also \code{numeric}). As with \code{truth} this can be
specified different ways but the primary method is to use an
unquoted variable name. For \verb{_vec()} functions, a \code{numeric} vector.}

\item{na_rm}{A \code{logical} value indicating whether \code{NA}
values should be stripped before the computation proceeds.}

\item{case_weights}{The optional column identifier for case weights. This
should be an unquoted column name that evaluates to a numeric column in
\code{data}. For \verb{_vec()} functions, a numeric vector,
\code{\link[hardhat:importance_weights]{hardhat::importance_weights()}}, or \code{\link[hardhat:frequency_weights]{hardhat::frequency_weights()}}.}
}
\value{
A \code{tibble} with columns \code{.metric}, \code{.estimator},
and \code{.estimate} and 1 row of values.

For grouped data frames, the number of rows returned will be the same as
the number of groups.

For \code{gini_coef_vec()}, a single \code{numeric} value (or \code{NA}).
}
\description{
Compute the normalized Gini coefficient, which measures the ranking ability
of a regression model based on the Lorenz curve. This metric is useful for
evaluating models that predict risk or loss costs, such as insurance pricing
models.
}
\details{
The normalized Gini coefficient is a metric that should be
maximized. The output ranges from
0 to 1, with
1 indicating perfect ranking ability where
predicted values perfectly rank the true values.

The Gini coefficient is calculated from the Lorenz curve, which plots the
cumulative proportion of the total truth values against the cumulative
proportion of observations when sorted by predicted values. The raw Gini is
the area between the Lorenz curve and the diagonal line of equality. The
normalized Gini divides this by the maximum possible Gini (achieved when
observations are sorted by the true values).

The formula is:

\deqn{\text{Normalized Gini} = \frac{G(\text{estimate})}{G(\text{truth})}}

where \eqn{G(x)} is the Gini coefficient when sorting by \eqn{x}.

Note that \code{gini_coef()} is a regression metric based on ranking, distinct
from \code{\link[=gain_capture]{gain_capture()}} which is a classification metric.

Unlike many other metrics, \code{gini_coef()} is not symmetric with respect to
\code{truth} and \code{estimate}. The \code{estimate} values determine the sorting order,
while the \code{truth} values are accumulated along the Lorenz curve. Swapping
them will produce different results.

When the true values are constant (zero variance), the Gini coefficient is
undefined and \code{NA} is returned with a warning.
}
\examples{
# Supply truth and predictions as bare column names
gini_coef(solubility_test, solubility, prediction)

library(dplyr)

set.seed(1234)
size <- 100
times <- 10

# create 10 resamples
solubility_resampled <- bind_rows(
  replicate(
    n = times,
    expr = sample_n(solubility_test, size, replace = TRUE),
    simplify = FALSE
  ),
  .id = "resample"
)

# Compute the metric by group
metric_results <- solubility_resampled |>
  group_by(resample) |>
  gini_coef(solubility, prediction)

metric_results

# Resampled mean estimate
metric_results |>
  summarise(avg_estimate = mean(.estimate))
}
\seealso{
\link[=numeric-metrics]{All numeric metrics}

Other numeric metrics: 
\code{\link{ccc}()},
\code{\link{huber_loss}()},
\code{\link{huber_loss_pseudo}()},
\code{\link{iic}()},
\code{\link{mae}()},
\code{\link{mape}()},
\code{\link{mase}()},
\code{\link{mpe}()},
\code{\link{msd}()},
\code{\link{mse}()},
\code{\link{poisson_log_loss}()},
\code{\link{rmse}()},
\code{\link{rmse_relative}()},
\code{\link{rpd}()},
\code{\link{rpiq}()},
\code{\link{rsq}()},
\code{\link{rsq_trad}()},
\code{\link{smape}()}
}
\concept{numeric metrics}
