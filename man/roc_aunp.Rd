% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/prob-roc_aunp.R
\name{roc_aunp}
\alias{roc_aunp}
\alias{roc_aunp.data.frame}
\alias{roc_aunp_vec}
\title{Area under the ROC curve of each class against the rest, using the a priori
class distribution}
\usage{
roc_aunp(data, ...)

\method{roc_aunp}{data.frame}(data, truth, ..., options = list(), na_rm = TRUE)

roc_aunp_vec(truth, estimate, options = list(), na_rm = TRUE, ...)
}
\arguments{
\item{data}{A \code{data.frame} containing the \code{truth} and \code{estimate}
columns.}

\item{...}{A set of unquoted column names or one or more \code{dplyr} selector
functions to choose which variables contain the class probabilities. There
should be as many columns as factor levels of \code{truth}.}

\item{truth}{The column identifier for the true class results
(that is a \code{factor}). This should be an unquoted column name although
this argument is passed by expression and supports
\link[rlang:quasiquotation]{quasiquotation} (you can unquote column
names). For \verb{_vec()} functions, a \code{factor} vector.}

\item{options}{A \code{list} of named options to pass to \code{\link[pROC:roc]{pROC::roc()}}
such as \code{direction} or \code{smooth}. These options should not include \code{response},
\code{predictor}, \code{levels}, or \code{quiet}.}

\item{na_rm}{A \code{logical} value indicating whether \code{NA}
values should be stripped before the computation proceeds.}

\item{estimate}{A matrix with as many
columns as factor levels of \code{truth}. \emph{It is assumed that these are in the
same order as the levels of \code{truth}.}}
}
\value{
A \code{tibble} with columns \code{.metric}, \code{.estimator},
and \code{.estimate} and 1 row of values.

For grouped data frames, the number of rows returned will be the same as
the number of groups.

For \code{roc_aunp_vec()}, a single \code{numeric} value (or \code{NA}).
}
\description{
\code{roc_aunp()} is a multiclass metric that computes the area under the ROC
curve of each class against the rest, using the a priori class distribution.
This is equivalent to \code{roc_auc(estimator = "macro_weighted")}.
}
\details{
Like the other ROC AUC metrics, \code{roc_aunp()} defaults to allowing
\code{pROC::roc()} control the direction of the computation, but allows you to
control this by passing \code{options = list(direction = "<")} or any other
allowed direction value. pROC advises setting the \code{direction} when doing
resampling so that the AUC values are not biased upwards.

Generally, an ROC AUC value is between \code{0.5} and \code{1}, with \code{1} being a
perfect prediction model. If your value is between \code{0} and \code{0.5}, then
this implies that you have meaningful information in your model, but it
is being applied incorrectly because doing the opposite of what the model
predicts would result in an AUC \verb{>0.5}.
}
\section{Relevant Level}{


There is no common convention on which factor level should
automatically be considered the "event" or "positive" result.
In \code{yardstick}, the default is to use the \emph{first} level. To
change this, a global option called \code{yardstick.event_first} is
set to \code{TRUE} when the package is loaded. This can be changed
to \code{FALSE} if the \emph{last} level of the factor is considered the
level of interest by running: \code{options(yardstick.event_first = FALSE)}.
For multiclass extensions involving one-vs-all
comparisons (such as macro averaging), this option is ignored and
the "one" level is always the relevant result.
}

\section{Multiclass}{

This multiclass method for computing the area under the ROC curve uses the
uniform class distribution and is equivalent to
\code{roc_auc(estimator = "macro_weighted")}.
}

\examples{
# Multiclass example

# `obs` is a 4 level factor. The first level is `"VF"`, which is the
# "event of interest" by default in yardstick. See the Relevant Level
# section above.
data(hpc_cv)

# You can use the col1:colN tidyselect syntax
library(dplyr)
hpc_cv \%>\%
  filter(Resample == "Fold01") \%>\%
  roc_aunp(obs, VF:L)

# Change the first level of `obs` from `"VF"` to `"M"` to alter the
# event of interest. The class probability columns should be supplied
# in the same order as the levels.
hpc_cv \%>\%
  filter(Resample == "Fold01") \%>\%
  mutate(obs = relevel(obs, "M")) \%>\%
  roc_aunp(obs, M, VF:L)

# Groups are respected
hpc_cv \%>\%
  group_by(Resample) \%>\%
  roc_aunp(obs, VF:L)

# Vector version
# Supply a matrix of class probabilities
fold1 <- hpc_cv \%>\%
  filter(Resample == "Fold01")

roc_aunp_vec(
  truth = fold1$obs,
  matrix(
    c(fold1$VF, fold1$F, fold1$M, fold1$L),
    ncol = 4
  )
)

# ---------------------------------------------------------------------------
# Options for `pROC::roc()`

# Pass options via a named list and not through `...`!
roc_aunp(
  hpc_cv,
  obs,
  VF:L,
  options = list(smooth = TRUE)
)

}
\references{
Ferri, C., Hern√°ndez-Orallo, J., & Modroiu, R. (2009). "An experimental
comparison of performance measures for classification". \emph{Pattern Recognition
Letters}. 30 (1), pp 27-38.
}
\seealso{
\code{\link[=roc_aunu]{roc_aunu()}} for computing the area under the ROC curve of each class against
the rest, using the uniform class distribution.

Other class probability metrics: 
\code{\link{average_precision}()},
\code{\link{gain_capture}()},
\code{\link{mn_log_loss}()},
\code{\link{pr_auc}()},
\code{\link{roc_auc}()},
\code{\link{roc_aunu}()}
}
\author{
Julia Silge
}
\concept{class probability metrics}
